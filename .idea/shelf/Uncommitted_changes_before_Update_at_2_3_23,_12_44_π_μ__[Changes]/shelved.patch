Index: edx/EdxCourse.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import html\nimport json\nimport sys\nimport time\nimport traceback\nfrom pathlib import Path\nimport re\nimport validators\nfrom bs4 import BeautifulSoup\n\nfrom Course import *\nfrom Exceptions import EdxInvalidCourseError, EdxRequestError, EdxNotEnrolledError\nfrom edx.EdxPlatform import Edx\n\n\nclass EdxCourse(Course):\n\n    def __init__(self, context: Edx, slug: str = None, *args, ):\n        super().__init__(context, slug, *args)\n        self.get_xblocks()\n        self.COURSE_OUTLINE_URL = '{}/{}'.format(self.COURSE_OUTLINE_BASE_URL, slug)\n\n    @Course.slug.setter\n    def slug(self, slug: str):\n        self._slug = slug if slug and slug.startswith('course-') else self.slug\n\n    @Course.url.setter\n    def url(self, url):\n        '''\n         This method expects a course's URL as argument, searches for it's xBlock structure and, if found, it returns it as a dictionary,else raises exception.\n        '''\n\n        log('Building xblocks.')\n        # TODO  URL CHECK START\n        # Break down the given course URL to get the course slug.\n        if validators.url(url):\n            for part in url.split('/'):\n                if part.startswith('course-'):\n                    self._slug = part\n\n                    return\n        else:\n            # If the conditions above are not passed, we will assume that a wrong\n            # course URL was passed in.\n            raise EdxInvalidCourseError('The provided course URL seems to be invalid.')\n\n        # if course_slug in self.collector.negative_results_id:\n        # \treturn\n\n    @Course.course_dir.setter\n    def course_dir(self, value):\n        for block, block_meta in value.items():\n            if block_meta.get('type') == 'course' and block_meta.get('display_name') is not None:\n                course_dir_name = block_meta.get('display_name')\n                dir_name_stripped = re.sub(r'[^\\w_ ]', '-', course_dir_name).replace('/', '-').strip()\n                self.course_dir = Path.joinpath(self.BASE_FILEPATH, self.platform, dir_name_stripped)\n                return\n        else:\n            self._course_dir = 'Unnamed EdxCourse'\n        # if course_slug in self.collector.negative_results_id:\n        # \treturn\n\n    @property\n    def course_title(self):\n        return self._course_title\n\n    @course_title.setter\n    def course_title(self, value):\n        for block, block_meta in value.items():\n            if block_meta.get('type') == 'course' and block_meta.get('display_name') is not None:\n                self._course_title = block_meta.get('display_name')\n                return\n\n        else:\n            self._course_title = 'Unnamed EdxCourse'\n\n    def get_xblocks(self, ):\n        # Construct the course outline URL\n\n        # We make an HTTP GET request to outline URL api\n        # and return a json object\n        # with xblocks:metadata which\n        # will allow us to map the course.\n\n        try:\n            outline_resp = self.client.get(self.COURSE_OUTLINE_URL, headers=self.headers)\n        except ConnectionError as e:\n            raise EdxRequestError(e)\n        try:\n            # course's xblock structure.\n            # blocks:metadata as keys:values\n            blocks = outline_resp.json()\n        except Exception as e:\n            print(traceback.format_exc(), e)\n            sys.exit(1)\n        blocks = blocks.get('course_blocks', None)\n        if blocks and blocks.get('blocks', None):\n            self.xblocks = blocks.get('blocks')\n            self.course_dir = self.course_dir()\n        else:\n            # If no blocks are found, we will assume that the user is not authorized\n            # to access the course.\n            raise EdxNotEnrolledError(\n                'No course content was found. Check the availability of the course and try again.')\n\n    def build_dir_tree(self):\n\n        self.lectures = {k: v for k, v in self.xblocks.items() if v['type'] == 'sequential'}\n        self.chapters = {k: v for k, v in self.xblocks.items() if v['type'] == 'chapter' and v['children'] is not None}\n\n        # course directory\n\n        if not Path(self.course_dir).exists():\n            # create course Directory\n            Path(self.course_dir).mkdir(parents=True, exist_ok=True)\n\n        for i, (lecture, lecture_meta) in enumerate(self.lectures.items()):\n            lecture_name = re.sub(r'[^\\w_ ]', '-', lecture_meta.get('display_name')).replace('/', '-')\n            for chapter, chapter_meta in self.chapters.items():\n                if lecture in chapter_meta.get('children'):\n                    chapter_name = re.sub(r'[^\\w_ ]', '-', chapter_meta.get('display_name')).replace('/', '-').strip()\n                    chapter_dir = Path.joinpath(self.course_dir, chapter_name)\n                    if not Path(chapter_dir).exists():\n                        # create lecture Directories\n                        Path(chapter_dir).mkdir(parents=True, exist_ok=True)\n                        print(f\"Creating folder: {chapter_dir}..\")\n                        print(\"..ok\")\n                    lecture_meta.update({'chapter': chapter_name})\n                    lecture_meta.update({'chapterID': chapter_meta.get('id')})\n                    lecture_meta.update({'course': self.course_dir})\n                    # lecture_meta.update({'directory': chapter_dir})\n\n                    filepath = Path(chapter_dir, '{segment} - ' + lecture_name)\n                    lecture_meta.update({'filepath': Path.joinpath(chapter_dir, filepath)})\n\n            # assuming that lectures are ordered .\n\n    def main_iterator(self, lectures, ):\n        # //TODO  mallon me class poy tha apofasizei poio tha anoiksei ap ta 2(constructor)\n\n        for i, (lecture, lecture_meta) in enumerate(lectures.items()):\n\n            lecture_url = \"{}/{}\".format(self.XBLOCK_BASE_URL, lecture)\n\n            soup = None\n            for j in range(3):\n                try:\n                    res = self.client.get(lecture_url,\n                                          headers=self.headers,\n                                          allow_redirects=True)\n                    soup = BeautifulSoup(html.unescape(res.text), 'lxml')\n                except Exception as e:\n                    if j == 2:\n                        raise EdxRequestError(e)\n                    time.sleep(5)\n                    print(\"RETRYING\")\n                    self.load()\n                    continue\n                else:\n                    break\n\n            try:\n                # KalturaScraper.KalturaScraper(lecture_meta, slug, soup)\n\n                DefaultEdxScraper(lecture, lecture_meta, self.slug, soup)\n            except (KeyboardInterrupt, ConnectionError):\n                self.collector.save_results()\n\n            # //TODO  με pandas και με DINJECTION\n            self.collector.negative_results_id.add(lecture)\n        else:\n            self.collector.negative_results_id.add(self.slug)\n\n\nclass DefaultEdxScraper(EdxCourse):\n\n    def scrape(self, lecture, lecture_meta, soup):\n        '''\n        # Searches through HTML elements\n        # Finds and builds URLs for subtitles and videos\n        '''\n        log(\"Entered Default\")\n\n        for i in soup.find_all('div', {'class': 'xblock-student_view-video'}):\n\n            header_block = i.find('h3', attrs={'class': 'hd hd-2'})\n            if header_block:\n                segment = re.sub(r'[^\\w_ ]', '-', header_block.text).replace('/', '-')\n                filepath = lecture_meta.get('filepath').format(segment=segment)\n\n                paragraphs = i.find_all('p')\n                if paragraphs and not Path(filepath).with_suffix('.pdf').exists():\n                    inner_html = i.decode_contents().replace('src=\"',\n                                                             f'src=\"{self.PROTOCOL_URL}/')\n                    inner_html = inner_html.replace(f'src=\"{self.PROTOCOL_URL}/http', 'src=\"http')\n                    try:\n                        self.collector.save_as_pdf(content=inner_html, path=filepath,\n                                                   id=lecture\n                                                   )\n                        log(\"PDF saved!\", \"orange\")\n                    except Exception as e:\n                        print(\"Problem while building PDF.\")\n                        print(e)\n\n                meta_block = i.find('div', {'class': 'video', 'data-metadata': True})\n\n                if meta_block:\n\n                    json_meta = json.loads(meta_block.get('data-metadata'))\n                    # Get the data-metadata attribute HTML\n                    # and parse it as a JSON object.\n                    prepared_item = {}\n                    if 'sources' in json_meta:\n\n                        for video_source in list(json_meta['sources']):\n                            if video_source.endswith('.mp4'):\n                                # video URL found\n                                log(f\"Struck gold! A video was found in segment: {filepath}!\",\n                                    \"orange\"\n                                    )\n                                log(video_source,\n                                    \"orange\"\n                                    )\n                                prepared_item.update(course_slug=self.slug,\n                                                     course=lecture_meta.get('course'),\n                                                     chapter=lecture_meta.get('chapter'),\n                                                     lecture=lecture_meta.get('display_name'),\n                                                     id=lecture,\n                                                     segment=segment,\n                                                     video_url=video_source,\n                                                     filepath=filepath)\n\n                                # Break the loop if a valid video URL\n                                # is found.\n                                subtitle_url = ''\n                                if 'transcriptAvailableTranslationsUrl' in json_meta:\n                                    # subtitle URL found\n                                    subtitle_url = '{}{}'.format(self.PROTOCOL_URL,\n                                                                 json_meta.get(\n                                                                     'transcriptAvailableTranslationsUrl')\n                                                                 .replace(\"available_translations\", \"download\")\n                                                                 )\n                                    log(f\"Subtitle was found for: {filepath}!\",\n                                        \"orange\"\n                                        )\n                                prepared_item.update(subtitle_url=subtitle_url)\n\n                                self.collector(**prepared_item)\n        return\n
===================================================================
diff --git a/edx/EdxCourse.py b/edx/EdxCourse.py
--- a/edx/EdxCourse.py	
+++ b/edx/EdxCourse.py	
@@ -154,7 +154,7 @@
                         raise EdxRequestError(e)
                     time.sleep(5)
                     print("RETRYING")
-                    self.load()
+                    self.load_cookies()
                     continue
                 else:
                     break
